#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import StyleDictionary from 'style-dictionary';
import { register, expandTypesMap } from '@tokens-studio/sd-transforms';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = path.resolve(__dirname, '..');
const TOKENS_DIR = path.join(ROOT_DIR, 'src', 'tokens');
const TOKENS_FILE = path.join(TOKENS_DIR, 'tokens.json');
const THEMES_OUTPUT_DIR = path.join(ROOT_DIR, 'src', 'styles', 'themes');
const MANIFEST_PATH = path.join(THEMES_OUTPUT_DIR, 'tokens.generated.ts');

const TARGET_THEMES = ['Engage', 'Legacy'];
const CSS_BANNER = `/*\n * -----------------------------------------------------------------------------\n * This file is auto-generated via scripts/generate-design-tokens.mjs.\n * Do not edit this file directly.\n * -----------------------------------------------------------------------------\n */\n\n`;
const TS_BANNER = `/**\n * -----------------------------------------------------------------------------\n * This file is auto-generated via scripts/generate-design-tokens.mjs.\n * Do not edit this file directly.\n * -----------------------------------------------------------------------------\n */\n\n`;

const slugify = (value) =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/-{2,}/g, '-');

const ensureBanner = (content, banner) => (content.startsWith(banner) ? content : `${banner}${content}`);
const FIVRA_THEME_ATTRIBUTE = 'data-fivra-theme';

const clearGeneratedThemeArtifacts = async () => {
  await fs.mkdir(THEMES_OUTPUT_DIR, { recursive: true });
  const entries = await fs.readdir(THEMES_OUTPUT_DIR, { withFileTypes: true }).catch(() => []);

  await Promise.all(
    entries
      .filter((entry) =>
        entry.isFile() && (entry.name.endsWith('.css') || entry.name === 'tokens.generated.ts'),
      )
      .map((entry) => fs.unlink(path.join(THEMES_OUTPUT_DIR, entry.name))),
  );
};

const formatThemeSelector = ({ slug, isDefault }) => {
  const attributeSelector = `[${FIVRA_THEME_ATTRIBUTE}='${slug}']`;
  return isDefault ? `:root, ${attributeSelector}` : attributeSelector;
};

const rewriteRootSelector = ({ cssContent, selector }) => {
  const pattern = /^:root(\s*\{)/gm;
  return cssContent.replace(pattern, `${selector}$1`);
};

const readJson = async (filePath) => {
  const content = await fs.readFile(filePath, 'utf8');
  return JSON.parse(content);
};

const resolveTokenSource = async (value) => {
  if (typeof value === 'string') {
    const absolute = path.resolve(TOKENS_DIR, value);
    return readJson(absolute);
  }
  return value;
};

const loadTokenBundle = async () => {
  const bundle = await readJson(TOKENS_FILE);

  const metadata = bundle.$metadata ? await resolveTokenSource(bundle.$metadata) : undefined;
  const themes = bundle.$themes ? await resolveTokenSource(bundle.$themes) : [];
  const setEntries = Object.entries(bundle.sets ?? {});
  const tokenSets = {};

  for (const [name, value] of setEntries) {
    if (typeof value === 'string') {
      const absolute = path.resolve(TOKENS_DIR, value);
      tokenSets[name] = {
        tokens: await readJson(absolute),
        path: absolute,
      };
    } else if (value && typeof value === 'object') {
      tokenSets[name] = {
        tokens: value,
        path: null,
      };
    } else {
      throw new Error(`Token set "${name}" must resolve to a JSON object or file path.`);
    }
  }

  return { metadata, themes, tokenSets };
};

const SOURCE_STATES = new Set(['enabled', 'source']);

const extractSetNames = (selectedTokenSets, prefix) => {
  if (!selectedTokenSets) {
    return [];
  }

  return Object.entries(selectedTokenSets)
    .filter(([setName, state]) => setName.startsWith(prefix) && SOURCE_STATES.has(state))
    .map(([setName]) => setName);
};

const resolveDictionarySource = (entry) => {
  if (entry.path) {
    return entry.path;
  }
  return { tokens: structuredClone(entry.tokens) };
};

const buildStyleDictionary = async ({
  externalSetNames,
  internalSetName,
  themeName,
  tokenSets,
  selector,
  slug,
}) => {
  const relativeOutputDir = path.relative(process.cwd(), THEMES_OUTPUT_DIR) || '.';
  const baseDictionary = new StyleDictionary();
  const externalEntries = externalSetNames.map((setName) => {
    const entry = tokenSets[setName];
    if (!entry) {
      throw new Error(`Token set "${setName}" is not defined in ${path.relative(ROOT_DIR, TOKENS_FILE)}`);
    }
    return entry;
  });
  const internalEntry = tokenSets[internalSetName];
  if (!internalEntry) {
    throw new Error(`Token set "${internalSetName}" is not defined in ${path.relative(ROOT_DIR, TOKENS_FILE)}`);
  }

  const externalFilePaths = new Set(externalEntries.map((entry) => entry.path).filter(Boolean));
  const internalFilePaths = new Set(internalEntry.path ? [internalEntry.path] : []);
  const filterToken = (token) => {
    if (externalFilePaths.size > 0) {
      return externalFilePaths.has(token.filePath);
    }
    if (internalFilePaths.size > 0) {
      return !internalFilePaths.has(token.filePath);
    }
    return true;
  };

  const dictionary = await baseDictionary.extend({
    include: [resolveDictionarySource(internalEntry)],
    source: externalEntries.map(resolveDictionarySource),
    expand: {
      typesMap: expandTypesMap,
    },
    platforms: {
      css: {
        transformGroup: 'tokens-studio',
        buildPath: relativeOutputDir.endsWith(path.sep)
          ? relativeOutputDir
          : `${relativeOutputDir}${path.sep}`,
        options: {
          showFileHeader: false,
          outputReferences: false,
        },
        files: [
          {
            destination: `${slug}.css`,
            format: 'css/variables',
            filter: filterToken,
          },
        ],
      },
    },
  });

  await dictionary.buildPlatform('css');

  const cssPath = path.join(THEMES_OUTPUT_DIR, `${slug}.css`);
  const cssContent = await fs.readFile(cssPath, 'utf8');
  const rewrittenCss = rewriteRootSelector({ cssContent, selector });
  await fs.writeFile(cssPath, ensureBanner(rewrittenCss, CSS_BANNER), 'utf8');

  return {
    cssPath,
  };
};

const formatManifest = ({ themes, metadata }) => {
  const manifest = {
    themeAttribute: FIVRA_THEME_ATTRIBUTE,
    themes: themes.map((theme) => ({
      name: theme.theme.name,
      id: theme.theme.id,
      group: theme.theme.group ?? null,
      cssPath: `./${theme.slug}.css`,
      slug: theme.slug,
      selector: theme.selector,
      isDefault: theme.isDefault,
      selectedTokenSets: theme.theme.selectedTokenSets,
      activeTokenSets: [...theme.setCombination.external, theme.setCombination.internal],
      tokenSetCombination: {
        external: [...theme.setCombination.external],
        internal: theme.setCombination.internal,
      },
    })),
    metadata: metadata ?? null,
  };

  const manifestBody = `${TS_BANNER}export const designTokenManifest = ${JSON.stringify(manifest, null, 2)} as const;\n\nexport type DesignTokenTheme = typeof designTokenManifest.themes[number];\nexport type DesignTokenThemeName = DesignTokenTheme['name'];\nexport type DesignTokenThemeSlug = DesignTokenTheme['slug'];\n`;

  return manifestBody;
};

const main = async () => {
  process.chdir(ROOT_DIR);
  await register(StyleDictionary, { platform: 'css' });

  const { metadata, themes, tokenSets } = await loadTokenBundle();
  if (!Array.isArray(themes) || themes.length === 0) {
    throw new Error(`No themes were found in ${path.relative(ROOT_DIR, TOKENS_FILE)}`);
  }

  await clearGeneratedThemeArtifacts();

  const manifestThemes = [];
  const externalTheme = themes.find((item) => item.group === 'Externals');
  if (!externalTheme) {
    throw new Error(`No theme with group "Externals" found in ${path.relative(ROOT_DIR, TOKENS_FILE)}`);
  }

  const externalSetNames = extractSetNames(externalTheme.selectedTokenSets, 'Externals/');
  if (externalSetNames.length === 0) {
    throw new Error(`Theme "${externalTheme.name}" does not enable any external token sets.`);
  }

  for (const [index, targetThemeName] of TARGET_THEMES.entries()) {
    const theme = themes.find((item) => item.name === targetThemeName);
    if (!theme) {
      throw new Error(`Theme "${targetThemeName}" is missing from ${path.relative(ROOT_DIR, TOKENS_FILE)}`);
    }

    const internalSetNames = extractSetNames(theme.selectedTokenSets, 'Internals/');
    if (internalSetNames.length !== 1) {
      throw new Error(
        `Theme "${targetThemeName}" must enable exactly one internal token set. Found ${internalSetNames.length}.`,
      );
    }

    const [internalSetName] = internalSetNames;

    const isDefault = index === 0;
    const slug = slugify(targetThemeName);
    const selector = formatThemeSelector({ slug, isDefault });

    const { cssPath } = await buildStyleDictionary({
      externalSetNames,
      internalSetName,
      themeName: targetThemeName,
      tokenSets,
      selector,
      slug,
    });
    manifestThemes.push({
      theme,
      slug,
      selector,
      isDefault,
      cssPath,
      setCombination: {
        external: [...externalSetNames],
        internal: internalSetName,
      },
    });
  }

  const manifestContent = formatManifest({
    themes: manifestThemes,
    metadata,
  });
  await fs.writeFile(MANIFEST_PATH, ensureBanner(manifestContent, TS_BANNER), 'utf8');
};

main().catch((error) => {
  console.error(`\nDesign token generation failed:`, error);
  process.exit(1);
});
