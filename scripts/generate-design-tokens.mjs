#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import StyleDictionary from 'style-dictionary';
import { register, permutateThemes, expandTypesMap } from '@tokens-studio/sd-transforms';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = path.resolve(__dirname, '..');
const TOKENS_DIR = path.join(ROOT_DIR, 'src', 'tokens');
const TOKENS_FILE = path.join(TOKENS_DIR, 'tokens.json');
const THEMES_OUTPUT_DIR = path.join(ROOT_DIR, 'src', 'styles', 'themes');
const MANIFEST_PATH = path.join(THEMES_OUTPUT_DIR, 'tokens.generated.ts');

const TARGET_THEMES = ['Engage', 'Legacy'];
const CSS_BANNER = `/*\n * -----------------------------------------------------------------------------\n * This file is auto-generated via scripts/generate-design-tokens.mjs.\n * Do not edit this file directly.\n * -----------------------------------------------------------------------------\n */\n\n`;
const TS_BANNER = `/**\n * -----------------------------------------------------------------------------\n * This file is auto-generated via scripts/generate-design-tokens.mjs.\n * Do not edit this file directly.\n * -----------------------------------------------------------------------------\n */\n\n`;

const slugify = (value) =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/-{2,}/g, '-');

const ensureBanner = (content, banner) => (content.startsWith(banner) ? content : `${banner}${content}`);

const deepMerge = (base, source) => {
  if (Array.isArray(base) || Array.isArray(source)) {
    return structuredClone(source);
  }

  if (typeof base !== 'object' || base === null) {
    return structuredClone(source);
  }

  const merged = { ...base };
  for (const [key, value] of Object.entries(source)) {
    if (value && typeof value === 'object' && !Array.isArray(value) && typeof merged[key] === 'object' && merged[key] !== null && !Array.isArray(merged[key])) {
      merged[key] = deepMerge(merged[key], value);
    } else {
      merged[key] = structuredClone(value);
    }
  }
  return merged;
};

const readJson = async (filePath) => {
  const content = await fs.readFile(filePath, 'utf8');
  return JSON.parse(content);
};

const resolveTokenSource = async (value) => {
  if (typeof value === 'string') {
    const absolute = path.resolve(TOKENS_DIR, value);
    return readJson(absolute);
  }
  return value;
};

const loadTokenBundle = async () => {
  const bundle = await readJson(TOKENS_FILE);

  const metadata = bundle.$metadata ? await resolveTokenSource(bundle.$metadata) : undefined;
  const themes = bundle.$themes ? await resolveTokenSource(bundle.$themes) : [];
  const setEntries = Object.entries(bundle.sets ?? {});
  const tokenSets = {};

  for (const [name, value] of setEntries) {
    tokenSets[name] = await resolveTokenSource(value);
  }

  return { metadata, themes, tokenSets };
};

const buildStyleDictionary = async ({ tokens, themeName }) => {
  const relativeOutputDir = path.relative(process.cwd(), THEMES_OUTPUT_DIR) || '.';
  const slug = slugify(themeName);
  const baseDictionary = new StyleDictionary();
  const dictionary = await baseDictionary.extend({
    tokens,
    expand: {
      typesMap: expandTypesMap,
    },
    platforms: {
      css: {
        transformGroup: 'tokens-studio',
        buildPath: relativeOutputDir.endsWith(path.sep)
          ? relativeOutputDir
          : `${relativeOutputDir}${path.sep}`,
        options: {
          showFileHeader: false,
        },
        files: [
          {
            destination: `${slug}.css`,
            format: 'css/variables',
          },
        ],
      },
    },
  });

  await dictionary.buildPlatform('css');

  const cssPath = path.join(THEMES_OUTPUT_DIR, `${slug}.css`);
  const cssContent = await fs.readFile(cssPath, 'utf8');
  await fs.writeFile(cssPath, ensureBanner(cssContent, CSS_BANNER), 'utf8');

  return {
    cssPath,
    slug,
  };
};

const formatManifest = ({ themes, metadata }) => {
  const manifest = {
    themes: themes.map((theme) => ({
      name: theme.theme.name,
      id: theme.theme.id,
      group: theme.theme.group ?? null,
      cssPath: `./${theme.slug}.css`,
      selectedTokenSets: theme.theme.selectedTokenSets,
      activeTokenSets: theme.activeSets,
    })),
    metadata: metadata ?? null,
  };

  const manifestBody = `${TS_BANNER}export const designTokenManifest = ${JSON.stringify(manifest, null, 2)} as const;\n\nexport type DesignTokenTheme = typeof designTokenManifest.themes[number];\nexport type DesignTokenThemeName = DesignTokenTheme['name'];\n`;

  return manifestBody;
};

const main = async () => {
  process.chdir(ROOT_DIR);
  await register(StyleDictionary, { platform: 'css' });

  const { metadata, themes, tokenSets } = await loadTokenBundle();
  if (!Array.isArray(themes) || themes.length === 0) {
    throw new Error(`No themes were found in ${path.relative(ROOT_DIR, TOKENS_FILE)}`);
  }

  await fs.rm(THEMES_OUTPUT_DIR, { recursive: true, force: true });
  await fs.mkdir(THEMES_OUTPUT_DIR, { recursive: true });

  const manifestThemes = [];

  for (const targetThemeName of TARGET_THEMES) {
    const theme = themes.find((item) => item.name === targetThemeName);
    if (!theme) {
      throw new Error(`Theme "${targetThemeName}" is missing from ${path.relative(ROOT_DIR, TOKENS_FILE)}`);
    }

    const permutations = permutateThemes([theme]);
    const activeSets = permutations[targetThemeName];
    if (!Array.isArray(activeSets) || activeSets.length === 0) {
      throw new Error(`Theme "${targetThemeName}" does not define any active token sets.`);
    }

    let mergedTokens = {};
    for (const setName of activeSets) {
      const setTokens = tokenSets[setName];
      if (!setTokens) {
        throw new Error(`Token set "${setName}" referenced by theme "${targetThemeName}" is missing.`);
      }
      mergedTokens = deepMerge(mergedTokens, setTokens);
    }

    const { cssPath, slug } = await buildStyleDictionary({ tokens: mergedTokens, themeName: targetThemeName });
    manifestThemes.push({
      theme,
      slug,
      cssPath,
      activeSets,
    });
  }

  const manifestContent = formatManifest({
    themes: manifestThemes,
    metadata,
  });
  await fs.writeFile(MANIFEST_PATH, ensureBanner(manifestContent, TS_BANNER), 'utf8');
};

main().catch((error) => {
  console.error(`\nDesign token generation failed:`, error);
  process.exit(1);
});
